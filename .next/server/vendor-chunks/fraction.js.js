"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fraction.js";
exports.ids = ["vendor-chunks/fraction.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/fraction.js/dist/fraction.mjs":
/*!****************************************************!*\
  !*** ./node_modules/fraction.js/dist/fraction.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fraction: () => (/* binding */ Fraction),\n/* harmony export */   \"default\": () => (/* binding */ Fraction)\n/* harmony export */ });\n\n\n/**\n *\n * This class offers the possibility to calculate fractions.\n * You can pass a fraction in different formats. Either as array, as double, as string or as an integer.\n *\n * Array/Object form\n * [ 0 => <numerator>, 1 => <denominator> ]\n * { n => <numerator>, d => <denominator> }\n *\n * Integer form\n * - Single integer value as BigInt or Number\n *\n * Double form\n * - Single double value as Number\n *\n * String form\n * 123.456 - a simple double\n * 123/456 - a string fraction\n * 123.'456' - a double with repeating decimal places\n * 123.(456) - synonym\n * 123.45'6' - a double with repeating last place\n * 123.45(6) - synonym\n *\n * Example:\n * let f = new Fraction(\"9.4'31'\");\n * f.mul([-4, 3]).div(4.9);\n *\n */\n\n// Set Identity function to downgrade BigInt to Number if needed\nif (typeof BigInt === 'undefined') BigInt = function (n) { if (isNaN(n)) throw new Error(\"\"); return n; };\n\nconst C_ZERO = BigInt(0);\nconst C_ONE = BigInt(1);\nconst C_TWO = BigInt(2);\nconst C_FIVE = BigInt(5);\nconst C_TEN = BigInt(10);\n\n// Maximum search depth for cyclic rational numbers. 2000 should be more than enough.\n// Example: 1/7 = 0.(142857) has 6 repeating decimal places.\n// If MAX_CYCLE_LEN gets reduced, long cycles will not be detected and toString() only gets the first 10 digits\nconst MAX_CYCLE_LEN = 2000;\n\n// Parsed data to avoid calling \"new\" all the time\nconst P = {\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE\n};\n\nfunction assign(n, s) {\n\n  try {\n    n = BigInt(n);\n  } catch (e) {\n    throw InvalidParameter();\n  }\n  return n * s;\n}\n\nfunction trunc(x) {\n  return typeof x === 'bigint' ? x : Math.floor(x);\n}\n\n// Creates a new Fraction internally without the need of the bulky constructor\nfunction newFraction(n, d) {\n\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n\n  const f = Object.create(Fraction.prototype);\n  f[\"s\"] = n < C_ZERO ? -C_ONE : C_ONE;\n\n  n = n < C_ZERO ? -n : n;\n\n  const a = gcd(n, d);\n\n  f[\"n\"] = n / a;\n  f[\"d\"] = d / a;\n  return f;\n}\n\nfunction factorize(num) {\n\n  const factors = {};\n\n  let n = num;\n  let i = C_TWO;\n  let s = C_FIVE - C_ONE;\n\n  while (s <= n) {\n\n    while (n % i === C_ZERO) {\n      n /= i;\n      factors[i] = (factors[i] || C_ZERO) + C_ONE;\n    }\n    s += C_ONE + C_TWO * i++;\n  }\n\n  if (n !== num) {\n    if (n > 1)\n      factors[n] = (factors[n] || C_ZERO) + C_ONE;\n  } else {\n    factors[num] = (factors[num] || C_ZERO) + C_ONE;\n  }\n  return factors;\n}\n\nconst parse = function (p1, p2) {\n\n  let n = C_ZERO, d = C_ONE, s = C_ONE;\n\n  if (p1 === undefined || p1 === null) { // No argument\n    /* void */\n  } else if (p2 !== undefined) { // Two arguments\n\n    if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else if (isNaN(p1)) {\n      throw InvalidParameter();\n    } else if (p1 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      n = BigInt(p1);\n    }\n\n    if (typeof p2 === \"bigint\") {\n      d = p2;\n    } else if (isNaN(p2)) {\n      throw InvalidParameter();\n    } else if (p2 % 1 !== 0) {\n      throw NonIntegerParameter();\n    } else {\n      d = BigInt(p2);\n    }\n\n    s = n * d;\n\n  } else if (typeof p1 === \"object\") {\n    if (\"d\" in p1 && \"n\" in p1) {\n      n = BigInt(p1[\"n\"]);\n      d = BigInt(p1[\"d\"]);\n      if (\"s\" in p1)\n        n *= BigInt(p1[\"s\"]);\n    } else if (0 in p1) {\n      n = BigInt(p1[0]);\n      if (1 in p1)\n        d = BigInt(p1[1]);\n    } else if (typeof p1 === \"bigint\") {\n      n = p1;\n    } else {\n      throw InvalidParameter();\n    }\n    s = n * d;\n  } else if (typeof p1 === \"number\") {\n\n    if (isNaN(p1)) {\n      throw InvalidParameter();\n    }\n\n    if (p1 < 0) {\n      s = -C_ONE;\n      p1 = -p1;\n    }\n\n    if (p1 % 1 === 0) {\n      n = BigInt(p1);\n    } else {\n\n      let z = 1;\n\n      let A = 0, B = 1;\n      let C = 1, D = 1;\n\n      let N = 10000000;\n\n      if (p1 >= 1) {\n        z = 10 ** Math.floor(1 + Math.log10(p1));\n        p1 /= z;\n      }\n\n      // Using Farey Sequences\n\n      while (B <= N && D <= N) {\n        let M = (A + C) / (B + D);\n\n        if (p1 === M) {\n          if (B + D <= N) {\n            n = A + C;\n            d = B + D;\n          } else if (D > B) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n          break;\n\n        } else {\n\n          if (p1 > M) {\n            A += C;\n            B += D;\n          } else {\n            C += A;\n            D += B;\n          }\n\n          if (B > N) {\n            n = C;\n            d = D;\n          } else {\n            n = A;\n            d = B;\n          }\n        }\n      }\n      n = BigInt(n) * BigInt(z);\n      d = BigInt(d);\n    }\n\n  } else if (typeof p1 === \"string\") {\n\n    let ndx = 0;\n\n    let v = C_ZERO, w = C_ZERO, x = C_ZERO, y = C_ONE, z = C_ONE;\n\n    let match = p1.replace(/_/g, '').match(/\\d+|./g);\n\n    if (match === null)\n      throw InvalidParameter();\n\n    if (match[ndx] === '-') {// Check for minus sign at the beginning\n      s = -C_ONE;\n      ndx++;\n    } else if (match[ndx] === '+') {// Check for plus sign at the beginning\n      ndx++;\n    }\n\n    if (match.length === ndx + 1) { // Check if it's just a simple number \"1234\"\n      w = assign(match[ndx++], s);\n    } else if (match[ndx + 1] === '.' || match[ndx] === '.') { // Check if it's a decimal number\n\n      if (match[ndx] !== '.') { // Handle 0.5 and .5\n        v = assign(match[ndx++], s);\n      }\n      ndx++;\n\n      // Check for decimal places\n      if (ndx + 1 === match.length || match[ndx + 1] === '(' && match[ndx + 3] === ')' || match[ndx + 1] === \"'\" && match[ndx + 3] === \"'\") {\n        w = assign(match[ndx], s);\n        y = C_TEN ** BigInt(match[ndx].length);\n        ndx++;\n      }\n\n      // Check for repeating places\n      if (match[ndx] === '(' && match[ndx + 2] === ')' || match[ndx] === \"'\" && match[ndx + 2] === \"'\") {\n        x = assign(match[ndx + 1], s);\n        z = C_TEN ** BigInt(match[ndx + 1].length) - C_ONE;\n        ndx += 3;\n      }\n\n    } else if (match[ndx + 1] === '/' || match[ndx + 1] === ':') { // Check for a simple fraction \"123/456\" or \"123:456\"\n      w = assign(match[ndx], s);\n      y = assign(match[ndx + 2], C_ONE);\n      ndx += 3;\n    } else if (match[ndx + 3] === '/' && match[ndx + 1] === ' ') { // Check for a complex fraction \"123 1/2\"\n      v = assign(match[ndx], s);\n      w = assign(match[ndx + 2], s);\n      y = assign(match[ndx + 4], C_ONE);\n      ndx += 5;\n    }\n\n    if (match.length <= ndx) { // Check for more tokens on the stack\n      d = y * z;\n      s = /* void */\n        n = x + d * v + z * w;\n    } else {\n      throw InvalidParameter();\n    }\n\n  } else if (typeof p1 === \"bigint\") {\n    n = p1;\n    s = p1;\n    d = C_ONE;\n  } else {\n    throw InvalidParameter();\n  }\n\n  if (d === C_ZERO) {\n    throw DivisionByZero();\n  }\n\n  P[\"s\"] = s < C_ZERO ? -C_ONE : C_ONE;\n  P[\"n\"] = n < C_ZERO ? -n : n;\n  P[\"d\"] = d < C_ZERO ? -d : d;\n};\n\nfunction modpow(b, e, m) {\n\n  let r = C_ONE;\n  for (; e > C_ZERO; b = (b * b) % m, e >>= C_ONE) {\n\n    if (e & C_ONE) {\n      r = (r * b) % m;\n    }\n  }\n  return r;\n}\n\nfunction cycleLen(n, d) {\n\n  for (; d % C_TWO === C_ZERO;\n    d /= C_TWO) {\n  }\n\n  for (; d % C_FIVE === C_ZERO;\n    d /= C_FIVE) {\n  }\n\n  if (d === C_ONE) // Catch non-cyclic numbers\n    return C_ZERO;\n\n  // If we would like to compute really large numbers quicker, we could make use of Fermat's little theorem:\n  // 10^(d-1) % d == 1\n  // However, we don't need such large numbers and MAX_CYCLE_LEN should be the capstone,\n  // as we want to translate the numbers to strings.\n\n  let rem = C_TEN % d;\n  let t = 1;\n\n  for (; rem !== C_ONE; t++) {\n    rem = rem * C_TEN % d;\n\n    if (t > MAX_CYCLE_LEN)\n      return C_ZERO; // Returning 0 here means that we don't print it as a cyclic number. It's likely that the answer is `d-1`\n  }\n  return BigInt(t);\n}\n\nfunction cycleStart(n, d, len) {\n\n  let rem1 = C_ONE;\n  let rem2 = modpow(C_TEN, len, d);\n\n  for (let t = 0; t < 300; t++) { // s < ~log10(Number.MAX_VALUE)\n    // Solve 10^s == 10^(s+t) (mod d)\n\n    if (rem1 === rem2)\n      return BigInt(t);\n\n    rem1 = rem1 * C_TEN % d;\n    rem2 = rem2 * C_TEN % d;\n  }\n  return 0;\n}\n\nfunction gcd(a, b) {\n\n  if (!a)\n    return b;\n  if (!b)\n    return a;\n\n  while (1) {\n    a %= b;\n    if (!a)\n      return b;\n    b %= a;\n    if (!b)\n      return a;\n  }\n}\n\n/**\n * Module constructor\n *\n * @constructor\n * @param {number|Fraction=} a\n * @param {number=} b\n */\nfunction Fraction(a, b) {\n\n  parse(a, b);\n\n  if (this instanceof Fraction) {\n    a = gcd(P[\"d\"], P[\"n\"]); // Abuse a\n    this[\"s\"] = P[\"s\"];\n    this[\"n\"] = P[\"n\"] / a;\n    this[\"d\"] = P[\"d\"] / a;\n  } else {\n    return newFraction(P['s'] * P['n'], P['d']);\n  }\n}\n\nvar DivisionByZero = function () { return new Error(\"Division by Zero\"); };\nvar InvalidParameter = function () { return new Error(\"Invalid argument\"); };\nvar NonIntegerParameter = function () { return new Error(\"Parameters must be integer\"); };\n\nFraction.prototype = {\n\n  \"s\": C_ONE,\n  \"n\": C_ZERO,\n  \"d\": C_ONE,\n\n  /**\n   * Calculates the absolute value\n   *\n   * Ex: new Fraction(-4).abs() => 4\n   **/\n  \"abs\": function () {\n\n    return newFraction(this[\"n\"], this[\"d\"]);\n  },\n\n  /**\n   * Inverts the sign of the current fraction\n   *\n   * Ex: new Fraction(-4).neg() => 4\n   **/\n  \"neg\": function () {\n\n    return newFraction(-this[\"s\"] * this[\"n\"], this[\"d\"]);\n  },\n\n  /**\n   * Adds two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => 467 / 30\n   **/\n  \"add\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * this[\"n\"] * P[\"d\"] + P[\"s\"] * this[\"d\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Subtracts two rational numbers\n   *\n   * Ex: new Fraction({n: 2, d: 3}).add(\"14.9\") => -427 / 30\n   **/\n  \"sub\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * this[\"d\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Multiplies two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").mul(3) => 5776 / 111\n   **/\n  \"mul\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"n\"],\n      this[\"d\"] * P[\"d\"]\n    );\n  },\n\n  /**\n   * Divides two rational numbers\n   *\n   * Ex: new Fraction(\"-17.(345)\").inverse().div(3)\n   **/\n  \"div\": function (a, b) {\n\n    parse(a, b);\n    return newFraction(\n      this[\"s\"] * P[\"s\"] * this[\"n\"] * P[\"d\"],\n      this[\"d\"] * P[\"n\"]\n    );\n  },\n\n  /**\n   * Clones the actual object\n   *\n   * Ex: new Fraction(\"-17.(345)\").clone()\n   **/\n  \"clone\": function () {\n    return newFraction(this['s'] * this['n'], this['d']);\n  },\n\n  /**\n   * Calculates the modulo of two rational numbers - a more precise fmod\n   *\n   * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)\n   * Ex: new Fraction(20, 10).mod().equals(0) ? \"is Integer\"\n   **/\n  \"mod\": function (a, b) {\n\n    if (a === undefined) {\n      return newFraction(this[\"s\"] * this[\"n\"] % this[\"d\"], C_ONE);\n    }\n\n    parse(a, b);\n    if (C_ZERO === P[\"n\"] * this[\"d\"]) {\n      throw DivisionByZero();\n    }\n\n    /**\n     * I derived the rational modulo similar to the modulo for integers\n     *\n     * https://raw.org/book/analysis/rational-numbers/\n     *\n     *    n1/d1 = (n2/d2) * q + r, where 0 ≤ r < n2/d2\n     * => d2 * n1 = n2 * d1 * q + d1 * d2 * r\n     * => r = (d2 * n1 - n2 * d1 * q) / (d1 * d2)\n     *      = (d2 * n1 - n2 * d1 * floor((d2 * n1) / (n2 * d1))) / (d1 * d2)\n     *      = ((d2 * n1) % (n2 * d1)) / (d1 * d2)\n     */\n    return newFraction(\n      this[\"s\"] * (P[\"d\"] * this[\"n\"]) % (P[\"n\"] * this[\"d\"]),\n      P[\"d\"] * this[\"d\"]);\n  },\n\n  /**\n   * Calculates the fractional gcd of two rational numbers\n   *\n   * Ex: new Fraction(5,8).gcd(3,7) => 1/56\n   */\n  \"gcd\": function (a, b) {\n\n    parse(a, b);\n\n    // https://raw.org/book/analysis/rational-numbers/\n    // gcd(a / b, c / d) = gcd(a, c) / lcm(b, d)\n\n    return newFraction(gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]), P[\"d\"] * this[\"d\"]);\n  },\n\n  /**\n   * Calculates the fractional lcm of two rational numbers\n   *\n   * Ex: new Fraction(5,8).lcm(3,7) => 15\n   */\n  \"lcm\": function (a, b) {\n\n    parse(a, b);\n\n    // https://raw.org/book/analysis/rational-numbers/\n    // lcm(a / b, c / d) = lcm(a, c) / gcd(b, d)\n\n    if (P[\"n\"] === C_ZERO && this[\"n\"] === C_ZERO) {\n      return newFraction(C_ZERO, C_ONE);\n    }\n    return newFraction(P[\"n\"] * this[\"n\"], gcd(P[\"n\"], this[\"n\"]) * gcd(P[\"d\"], this[\"d\"]));\n  },\n\n  /**\n   * Gets the inverse of the fraction, means numerator and denominator are exchanged\n   *\n   * Ex: new Fraction([-3, 4]).inverse() => -4 / 3\n   **/\n  \"inverse\": function () {\n    return newFraction(this[\"s\"] * this[\"d\"], this[\"n\"]);\n  },\n\n  /**\n   * Calculates the fraction to some integer exponent\n   *\n   * Ex: new Fraction(-1,2).pow(-3) => -8\n   */\n  \"pow\": function (a, b) {\n\n    parse(a, b);\n\n    // Trivial case when exp is an integer\n\n    if (P['d'] === C_ONE) {\n\n      if (P['s'] < C_ZERO) {\n        return newFraction((this['s'] * this[\"d\"]) ** P['n'], this[\"n\"] ** P['n']);\n      } else {\n        return newFraction((this['s'] * this[\"n\"]) ** P['n'], this[\"d\"] ** P['n']);\n      }\n    }\n\n    // Negative roots become complex\n    //     (-a/b)^(c/d) = x\n    // ⇔ (-1)^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(pi) + i*sin(pi))^(c/d) * (a/b)^(c/d) = x\n    // ⇔ (cos(c*pi/d) + i*sin(c*pi/d)) * (a/b)^(c/d) = x       # DeMoivre's formula\n    // From which follows that only for c=0 the root is non-complex\n    if (this['s'] < C_ZERO) return null;\n\n    // Now prime factor n and d\n    let N = factorize(this['n']);\n    let D = factorize(this['d']);\n\n    // Exponentiate and take root for n and d individually\n    let n = C_ONE;\n    let d = C_ONE;\n    for (let k in N) {\n      if (k === '1') continue;\n      if (k === '0') {\n        n = C_ZERO;\n        break;\n      }\n      N[k] *= P['n'];\n\n      if (N[k] % P['d'] === C_ZERO) {\n        N[k] /= P['d'];\n      } else return null;\n      n *= BigInt(k) ** N[k];\n    }\n\n    for (let k in D) {\n      if (k === '1') continue;\n      D[k] *= P['n'];\n\n      if (D[k] % P['d'] === C_ZERO) {\n        D[k] /= P['d'];\n      } else return null;\n      d *= BigInt(k) ** D[k];\n    }\n\n    if (P['s'] < C_ZERO) {\n      return newFraction(d, n);\n    }\n    return newFraction(n, d);\n  },\n\n  /**\n   * Calculates the logarithm of a fraction to a given rational base\n   *\n   * Ex: new Fraction(27, 8).log(9, 4) => 3/2\n   */\n  \"log\": function (a, b) {\n\n    parse(a, b);\n\n    if (this['s'] <= C_ZERO || P['s'] <= C_ZERO) return null;\n\n    const allPrimes = {};\n\n    const baseFactors = factorize(P['n']);\n    const T1 = factorize(P['d']);\n\n    const numberFactors = factorize(this['n']);\n    const T2 = factorize(this['d']);\n\n    for (const prime in T1) {\n      baseFactors[prime] = (baseFactors[prime] || C_ZERO) - T1[prime];\n    }\n    for (const prime in T2) {\n      numberFactors[prime] = (numberFactors[prime] || C_ZERO) - T2[prime];\n    }\n\n    for (const prime in baseFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n    for (const prime in numberFactors) {\n      if (prime === '1') continue;\n      allPrimes[prime] = true;\n    }\n\n    let retN = null;\n    let retD = null;\n\n    // Iterate over all unique primes to determine if a consistent ratio exists\n    for (const prime in allPrimes) {\n\n      const baseExponent = baseFactors[prime] || C_ZERO;\n      const numberExponent = numberFactors[prime] || C_ZERO;\n\n      if (baseExponent === C_ZERO) {\n        if (numberExponent !== C_ZERO) {\n          return null; // Logarithm cannot be expressed as a rational number\n        }\n        continue; // Skip this prime since both exponents are zero\n      }\n\n      // Calculate the ratio of exponents for this prime\n      let curN = numberExponent;\n      let curD = baseExponent;\n\n      // Simplify the current ratio\n      const gcdValue = gcd(curN, curD);\n      curN /= gcdValue;\n      curD /= gcdValue;\n\n      // Check if this is the first ratio; otherwise, ensure ratios are consistent\n      if (retN === null && retD === null) {\n        retN = curN;\n        retD = curD;\n      } else if (curN * retD !== retN * curD) {\n        return null; // Ratios do not match, logarithm cannot be rational\n      }\n    }\n\n    return retN !== null && retD !== null\n      ? newFraction(retN, retD)\n      : null;\n  },\n\n  /**\n   * Check if two rational numbers are the same\n   *\n   * Ex: new Fraction(19.6).equals([98, 5]);\n   **/\n  \"equals\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] === P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is less than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lt\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] < P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is less than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"lte\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] <= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is greater than another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gt\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] > P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Check if this rational number is greater than or equal another\n   *\n   * Ex: new Fraction(19.6).lt([98, 5]);\n   **/\n  \"gte\": function (a, b) {\n\n    parse(a, b);\n    return this[\"s\"] * this[\"n\"] * P[\"d\"] >= P[\"s\"] * P[\"n\"] * this[\"d\"];\n  },\n\n  /**\n   * Compare two rational numbers\n   * < 0 iff this < that\n   * > 0 iff this > that\n   * = 0 iff this = that\n   *\n   * Ex: new Fraction(19.6).compare([98, 5]);\n   **/\n  \"compare\": function (a, b) {\n\n    parse(a, b);\n    let t = this[\"s\"] * this[\"n\"] * P[\"d\"] - P[\"s\"] * P[\"n\"] * this[\"d\"];\n\n    return (C_ZERO < t) - (t < C_ZERO);\n  },\n\n  /**\n   * Calculates the ceil of a rational number\n   *\n   * Ex: new Fraction('4.(3)').ceil() => (5 / 1)\n   **/\n  \"ceil\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    return newFraction(trunc(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) +\n      (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n   * Calculates the floor of a rational number\n   *\n   * Ex: new Fraction('4.(3)').floor() => (4 / 1)\n   **/\n  \"floor\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    return newFraction(trunc(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) -\n      (places * this[\"n\"] % this[\"d\"] > C_ZERO && this[\"s\"] < C_ZERO ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n   * Rounds a rational numbers\n   *\n   * Ex: new Fraction('4.(3)').round() => (4 / 1)\n   **/\n  \"round\": function (places) {\n\n    places = C_TEN ** BigInt(places || 0);\n\n    /* Derivation:\n\n    s >= 0:\n      round(n / d) = trunc(n / d) + (n % d) / d >= 0.5 ? 1 : 0\n                   = trunc(n / d) + 2(n % d) >= d ? 1 : 0\n    s < 0:\n      round(n / d) =-trunc(n / d) - (n % d) / d > 0.5 ? 1 : 0\n                   =-trunc(n / d) - 2(n % d) > d ? 1 : 0\n\n    =>:\n\n    round(s * n / d) = s * trunc(n / d) + s * (C + 2(n % d) > d ? 1 : 0)\n        where C = s >= 0 ? 1 : 0, to fix the >= for the positve case.\n    */\n\n    return newFraction(trunc(this[\"s\"] * places * this[\"n\"] / this[\"d\"]) +\n      this[\"s\"] * ((this[\"s\"] >= C_ZERO ? C_ONE : C_ZERO) + C_TWO * (places * this[\"n\"] % this[\"d\"]) > this[\"d\"] ? C_ONE : C_ZERO),\n      places);\n  },\n\n  /**\n    * Rounds a rational number to a multiple of another rational number\n    *\n    * Ex: new Fraction('0.9').roundTo(\"1/8\") => 7 / 8\n    **/\n  \"roundTo\": function (a, b) {\n\n    /*\n    k * x/y ≤ a/b < (k+1) * x/y\n    ⇔ k ≤ a/b / (x/y) < (k+1)\n    ⇔ k = floor(a/b * y/x)\n    ⇔ k = floor((a * y) / (b * x))\n    */\n\n    parse(a, b);\n\n    const n = this['n'] * P['d'];\n    const d = this['d'] * P['n'];\n    const r = n % d;\n\n    // round(n / d) = trunc(n / d) + 2(n % d) >= d ? 1 : 0\n    let k = trunc(n / d);\n    if (r + r >= d) {\n      k++;\n    }\n    return newFraction(this['s'] * k * P['n'], P['d']);\n  },\n\n  /**\n   * Check if two rational numbers are divisible\n   *\n   * Ex: new Fraction(19.6).divisible(1.5);\n   */\n  \"divisible\": function (a, b) {\n\n    parse(a, b);\n    return !(!(P[\"n\"] * this[\"d\"]) || ((this[\"n\"] * P[\"d\"]) % (P[\"n\"] * this[\"d\"])));\n  },\n\n  /**\n   * Returns a decimal representation of the fraction\n   *\n   * Ex: new Fraction(\"100.'91823'\").valueOf() => 100.91823918239183\n   **/\n  'valueOf': function () {\n    // Best we can do so far\n    return Number(this[\"s\"] * this[\"n\"]) / Number(this[\"d\"]);\n  },\n\n  /**\n   * Creates a string representation of a fraction with all digits\n   *\n   * Ex: new Fraction(\"100.'91823'\").toString() => \"100.(91823)\"\n   **/\n  'toString': function (dec) {\n\n    let N = this[\"n\"];\n    let D = this[\"d\"];\n\n    dec = dec || 15; // 15 = decimal places when no repetition\n\n    let cycLen = cycleLen(N, D); // Cycle length\n    let cycOff = cycleStart(N, D, cycLen); // Cycle start\n\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    // Append integer part\n    str += trunc(N / D);\n\n    N %= D;\n    N *= C_TEN;\n\n    if (N)\n      str += \".\";\n\n    if (cycLen) {\n\n      for (let i = cycOff; i--;) {\n        str += trunc(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \"(\";\n      for (let i = cycLen; i--;) {\n        str += trunc(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n      str += \")\";\n    } else {\n      for (let i = dec; N && i--;) {\n        str += trunc(N / D);\n        N %= D;\n        N *= C_TEN;\n      }\n    }\n    return str;\n  },\n\n  /**\n   * Returns a string-fraction representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toFraction() => \"4 1/3\"\n   **/\n  'toFraction': function (showMixed) {\n\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      let whole = trunc(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        str += \" \";\n        n %= d;\n      }\n\n      str += n;\n      str += '/';\n      str += d;\n    }\n    return str;\n  },\n\n  /**\n   * Returns a latex representation of a Fraction object\n   *\n   * Ex: new Fraction(\"1.'3'\").toLatex() => \"\\frac{4}{3}\"\n   **/\n  'toLatex': function (showMixed) {\n\n    let n = this[\"n\"];\n    let d = this[\"d\"];\n    let str = this['s'] < C_ZERO ? \"-\" : \"\";\n\n    if (d === C_ONE) {\n      str += n;\n    } else {\n      let whole = trunc(n / d);\n      if (showMixed && whole > C_ZERO) {\n        str += whole;\n        n %= d;\n      }\n\n      str += \"\\\\frac{\";\n      str += n;\n      str += '}{';\n      str += d;\n      str += '}';\n    }\n    return str;\n  },\n\n  /**\n   * Returns an array of continued fraction elements\n   *\n   * Ex: new Fraction(\"7/8\").toContinued() => [0,1,7]\n   */\n  'toContinued': function () {\n\n    let a = this['n'];\n    let b = this['d'];\n    let res = [];\n\n    do {\n      res.push(trunc(a / b));\n      let t = a % b;\n      a = b;\n      b = t;\n    } while (a !== C_ONE);\n\n    return res;\n  },\n\n  \"simplify\": function (eps) {\n\n    const ieps = BigInt(1 / (eps || 0.001) | 0);\n\n    const thisABS = this['abs']();\n    const cont = thisABS['toContinued']();\n\n    for (let i = 1; i < cont.length; i++) {\n\n      let s = newFraction(cont[i - 1], C_ONE);\n      for (let k = i - 2; k >= 0; k--) {\n        s = s['inverse']()['add'](cont[k]);\n      }\n\n      let t = s['sub'](thisABS);\n      if (t['n'] * ieps < t['d']) { // More robust than Math.abs(t.valueOf()) < eps\n        return s['mul'](this['s']);\n      }\n    }\n    return this;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnJhY3Rpb24uanMvZGlzdC9mcmFjdGlvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELG1DQUFtQzs7QUFFOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQSxJQUFJLDZCQUE2Qjs7QUFFakM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLE1BQU0sOEJBQThCO0FBQ3BDO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0EsTUFBTSx5REFBeUQ7O0FBRS9ELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLDZEQUE2RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZEQUE2RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUyxZQUFZOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMsZUFBZTtBQUN4Qjs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUyxPQUFPO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQyxxQ0FBcUM7QUFDckMsd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7O0FBRXJCLGlDQUFpQztBQUNqQywyQ0FBMkM7O0FBRTNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsR0FBRyxFQUFFO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCOztBQUVyQztBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIi9ob21lL2hhcnJ5Y2hlbi9wcm9qZWN0L2Z1bmN0aW9uLXBsb3R0ZXIvbm9kZV9tb2R1bGVzL2ZyYWN0aW9uLmpzL2Rpc3QvZnJhY3Rpb24ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKlxuICogVGhpcyBjbGFzcyBvZmZlcnMgdGhlIHBvc3NpYmlsaXR5IHRvIGNhbGN1bGF0ZSBmcmFjdGlvbnMuXG4gKiBZb3UgY2FuIHBhc3MgYSBmcmFjdGlvbiBpbiBkaWZmZXJlbnQgZm9ybWF0cy4gRWl0aGVyIGFzIGFycmF5LCBhcyBkb3VibGUsIGFzIHN0cmluZyBvciBhcyBhbiBpbnRlZ2VyLlxuICpcbiAqIEFycmF5L09iamVjdCBmb3JtXG4gKiBbIDAgPT4gPG51bWVyYXRvcj4sIDEgPT4gPGRlbm9taW5hdG9yPiBdXG4gKiB7IG4gPT4gPG51bWVyYXRvcj4sIGQgPT4gPGRlbm9taW5hdG9yPiB9XG4gKlxuICogSW50ZWdlciBmb3JtXG4gKiAtIFNpbmdsZSBpbnRlZ2VyIHZhbHVlIGFzIEJpZ0ludCBvciBOdW1iZXJcbiAqXG4gKiBEb3VibGUgZm9ybVxuICogLSBTaW5nbGUgZG91YmxlIHZhbHVlIGFzIE51bWJlclxuICpcbiAqIFN0cmluZyBmb3JtXG4gKiAxMjMuNDU2IC0gYSBzaW1wbGUgZG91YmxlXG4gKiAxMjMvNDU2IC0gYSBzdHJpbmcgZnJhY3Rpb25cbiAqIDEyMy4nNDU2JyAtIGEgZG91YmxlIHdpdGggcmVwZWF0aW5nIGRlY2ltYWwgcGxhY2VzXG4gKiAxMjMuKDQ1NikgLSBzeW5vbnltXG4gKiAxMjMuNDUnNicgLSBhIGRvdWJsZSB3aXRoIHJlcGVhdGluZyBsYXN0IHBsYWNlXG4gKiAxMjMuNDUoNikgLSBzeW5vbnltXG4gKlxuICogRXhhbXBsZTpcbiAqIGxldCBmID0gbmV3IEZyYWN0aW9uKFwiOS40JzMxJ1wiKTtcbiAqIGYubXVsKFstNCwgM10pLmRpdig0LjkpO1xuICpcbiAqL1xuXG4vLyBTZXQgSWRlbnRpdHkgZnVuY3Rpb24gdG8gZG93bmdyYWRlIEJpZ0ludCB0byBOdW1iZXIgaWYgbmVlZGVkXG5pZiAodHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcpIEJpZ0ludCA9IGZ1bmN0aW9uIChuKSB7IGlmIChpc05hTihuKSkgdGhyb3cgbmV3IEVycm9yKFwiXCIpOyByZXR1cm4gbjsgfTtcblxuY29uc3QgQ19aRVJPID0gQmlnSW50KDApO1xuY29uc3QgQ19PTkUgPSBCaWdJbnQoMSk7XG5jb25zdCBDX1RXTyA9IEJpZ0ludCgyKTtcbmNvbnN0IENfRklWRSA9IEJpZ0ludCg1KTtcbmNvbnN0IENfVEVOID0gQmlnSW50KDEwKTtcblxuLy8gTWF4aW11bSBzZWFyY2ggZGVwdGggZm9yIGN5Y2xpYyByYXRpb25hbCBudW1iZXJzLiAyMDAwIHNob3VsZCBiZSBtb3JlIHRoYW4gZW5vdWdoLlxuLy8gRXhhbXBsZTogMS83ID0gMC4oMTQyODU3KSBoYXMgNiByZXBlYXRpbmcgZGVjaW1hbCBwbGFjZXMuXG4vLyBJZiBNQVhfQ1lDTEVfTEVOIGdldHMgcmVkdWNlZCwgbG9uZyBjeWNsZXMgd2lsbCBub3QgYmUgZGV0ZWN0ZWQgYW5kIHRvU3RyaW5nKCkgb25seSBnZXRzIHRoZSBmaXJzdCAxMCBkaWdpdHNcbmNvbnN0IE1BWF9DWUNMRV9MRU4gPSAyMDAwO1xuXG4vLyBQYXJzZWQgZGF0YSB0byBhdm9pZCBjYWxsaW5nIFwibmV3XCIgYWxsIHRoZSB0aW1lXG5jb25zdCBQID0ge1xuICBcInNcIjogQ19PTkUsXG4gIFwiblwiOiBDX1pFUk8sXG4gIFwiZFwiOiBDX09ORVxufTtcblxuZnVuY3Rpb24gYXNzaWduKG4sIHMpIHtcblxuICB0cnkge1xuICAgIG4gPSBCaWdJbnQobik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG4gIH1cbiAgcmV0dXJuIG4gKiBzO1xufVxuXG5mdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgPyB4IDogTWF0aC5mbG9vcih4KTtcbn1cblxuLy8gQ3JlYXRlcyBhIG5ldyBGcmFjdGlvbiBpbnRlcm5hbGx5IHdpdGhvdXQgdGhlIG5lZWQgb2YgdGhlIGJ1bGt5IGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBuZXdGcmFjdGlvbihuLCBkKSB7XG5cbiAgaWYgKGQgPT09IENfWkVSTykge1xuICAgIHRocm93IERpdmlzaW9uQnlaZXJvKCk7XG4gIH1cblxuICBjb25zdCBmID0gT2JqZWN0LmNyZWF0ZShGcmFjdGlvbi5wcm90b3R5cGUpO1xuICBmW1wic1wiXSA9IG4gPCBDX1pFUk8gPyAtQ19PTkUgOiBDX09ORTtcblxuICBuID0gbiA8IENfWkVSTyA/IC1uIDogbjtcblxuICBjb25zdCBhID0gZ2NkKG4sIGQpO1xuXG4gIGZbXCJuXCJdID0gbiAvIGE7XG4gIGZbXCJkXCJdID0gZCAvIGE7XG4gIHJldHVybiBmO1xufVxuXG5mdW5jdGlvbiBmYWN0b3JpemUobnVtKSB7XG5cbiAgY29uc3QgZmFjdG9ycyA9IHt9O1xuXG4gIGxldCBuID0gbnVtO1xuICBsZXQgaSA9IENfVFdPO1xuICBsZXQgcyA9IENfRklWRSAtIENfT05FO1xuXG4gIHdoaWxlIChzIDw9IG4pIHtcblxuICAgIHdoaWxlIChuICUgaSA9PT0gQ19aRVJPKSB7XG4gICAgICBuIC89IGk7XG4gICAgICBmYWN0b3JzW2ldID0gKGZhY3RvcnNbaV0gfHwgQ19aRVJPKSArIENfT05FO1xuICAgIH1cbiAgICBzICs9IENfT05FICsgQ19UV08gKiBpKys7XG4gIH1cblxuICBpZiAobiAhPT0gbnVtKSB7XG4gICAgaWYgKG4gPiAxKVxuICAgICAgZmFjdG9yc1tuXSA9IChmYWN0b3JzW25dIHx8IENfWkVSTykgKyBDX09ORTtcbiAgfSBlbHNlIHtcbiAgICBmYWN0b3JzW251bV0gPSAoZmFjdG9yc1tudW1dIHx8IENfWkVSTykgKyBDX09ORTtcbiAgfVxuICByZXR1cm4gZmFjdG9ycztcbn1cblxuY29uc3QgcGFyc2UgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG5cbiAgbGV0IG4gPSBDX1pFUk8sIGQgPSBDX09ORSwgcyA9IENfT05FO1xuXG4gIGlmIChwMSA9PT0gdW5kZWZpbmVkIHx8IHAxID09PSBudWxsKSB7IC8vIE5vIGFyZ3VtZW50XG4gICAgLyogdm9pZCAqL1xuICB9IGVsc2UgaWYgKHAyICE9PSB1bmRlZmluZWQpIHsgLy8gVHdvIGFyZ3VtZW50c1xuXG4gICAgaWYgKHR5cGVvZiBwMSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgbiA9IHAxO1xuICAgIH0gZWxzZSBpZiAoaXNOYU4ocDEpKSB7XG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG4gICAgfSBlbHNlIGlmIChwMSAlIDEgIT09IDApIHtcbiAgICAgIHRocm93IE5vbkludGVnZXJQYXJhbWV0ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbiA9IEJpZ0ludChwMSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwMiA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgZCA9IHAyO1xuICAgIH0gZWxzZSBpZiAoaXNOYU4ocDIpKSB7XG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG4gICAgfSBlbHNlIGlmIChwMiAlIDEgIT09IDApIHtcbiAgICAgIHRocm93IE5vbkludGVnZXJQYXJhbWV0ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCA9IEJpZ0ludChwMik7XG4gICAgfVxuXG4gICAgcyA9IG4gKiBkO1xuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHAxID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKFwiZFwiIGluIHAxICYmIFwiblwiIGluIHAxKSB7XG4gICAgICBuID0gQmlnSW50KHAxW1wiblwiXSk7XG4gICAgICBkID0gQmlnSW50KHAxW1wiZFwiXSk7XG4gICAgICBpZiAoXCJzXCIgaW4gcDEpXG4gICAgICAgIG4gKj0gQmlnSW50KHAxW1wic1wiXSk7XG4gICAgfSBlbHNlIGlmICgwIGluIHAxKSB7XG4gICAgICBuID0gQmlnSW50KHAxWzBdKTtcbiAgICAgIGlmICgxIGluIHAxKVxuICAgICAgICBkID0gQmlnSW50KHAxWzFdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwMSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgbiA9IHAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG4gICAgfVxuICAgIHMgPSBuICogZDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcDEgPT09IFwibnVtYmVyXCIpIHtcblxuICAgIGlmIChpc05hTihwMSkpIHtcbiAgICAgIHRocm93IEludmFsaWRQYXJhbWV0ZXIoKTtcbiAgICB9XG5cbiAgICBpZiAocDEgPCAwKSB7XG4gICAgICBzID0gLUNfT05FO1xuICAgICAgcDEgPSAtcDE7XG4gICAgfVxuXG4gICAgaWYgKHAxICUgMSA9PT0gMCkge1xuICAgICAgbiA9IEJpZ0ludChwMSk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgbGV0IHogPSAxO1xuXG4gICAgICBsZXQgQSA9IDAsIEIgPSAxO1xuICAgICAgbGV0IEMgPSAxLCBEID0gMTtcblxuICAgICAgbGV0IE4gPSAxMDAwMDAwMDtcblxuICAgICAgaWYgKHAxID49IDEpIHtcbiAgICAgICAgeiA9IDEwICoqIE1hdGguZmxvb3IoMSArIE1hdGgubG9nMTAocDEpKTtcbiAgICAgICAgcDEgLz0gejtcbiAgICAgIH1cblxuICAgICAgLy8gVXNpbmcgRmFyZXkgU2VxdWVuY2VzXG5cbiAgICAgIHdoaWxlIChCIDw9IE4gJiYgRCA8PSBOKSB7XG4gICAgICAgIGxldCBNID0gKEEgKyBDKSAvIChCICsgRCk7XG5cbiAgICAgICAgaWYgKHAxID09PSBNKSB7XG4gICAgICAgICAgaWYgKEIgKyBEIDw9IE4pIHtcbiAgICAgICAgICAgIG4gPSBBICsgQztcbiAgICAgICAgICAgIGQgPSBCICsgRDtcbiAgICAgICAgICB9IGVsc2UgaWYgKEQgPiBCKSB7XG4gICAgICAgICAgICBuID0gQztcbiAgICAgICAgICAgIGQgPSBEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuID0gQTtcbiAgICAgICAgICAgIGQgPSBCO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKHAxID4gTSkge1xuICAgICAgICAgICAgQSArPSBDO1xuICAgICAgICAgICAgQiArPSBEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBDICs9IEE7XG4gICAgICAgICAgICBEICs9IEI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEIgPiBOKSB7XG4gICAgICAgICAgICBuID0gQztcbiAgICAgICAgICAgIGQgPSBEO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuID0gQTtcbiAgICAgICAgICAgIGQgPSBCO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbiA9IEJpZ0ludChuKSAqIEJpZ0ludCh6KTtcbiAgICAgIGQgPSBCaWdJbnQoZCk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHAxID09PSBcInN0cmluZ1wiKSB7XG5cbiAgICBsZXQgbmR4ID0gMDtcblxuICAgIGxldCB2ID0gQ19aRVJPLCB3ID0gQ19aRVJPLCB4ID0gQ19aRVJPLCB5ID0gQ19PTkUsIHogPSBDX09ORTtcblxuICAgIGxldCBtYXRjaCA9IHAxLnJlcGxhY2UoL18vZywgJycpLm1hdGNoKC9cXGQrfC4vZyk7XG5cbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG5cbiAgICBpZiAobWF0Y2hbbmR4XSA9PT0gJy0nKSB7Ly8gQ2hlY2sgZm9yIG1pbnVzIHNpZ24gYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgcyA9IC1DX09ORTtcbiAgICAgIG5keCsrO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbbmR4XSA9PT0gJysnKSB7Ly8gQ2hlY2sgZm9yIHBsdXMgc2lnbiBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICBuZHgrKztcbiAgICB9XG5cbiAgICBpZiAobWF0Y2gubGVuZ3RoID09PSBuZHggKyAxKSB7IC8vIENoZWNrIGlmIGl0J3MganVzdCBhIHNpbXBsZSBudW1iZXIgXCIxMjM0XCJcbiAgICAgIHcgPSBhc3NpZ24obWF0Y2hbbmR4KytdLCBzKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoW25keCArIDFdID09PSAnLicgfHwgbWF0Y2hbbmR4XSA9PT0gJy4nKSB7IC8vIENoZWNrIGlmIGl0J3MgYSBkZWNpbWFsIG51bWJlclxuXG4gICAgICBpZiAobWF0Y2hbbmR4XSAhPT0gJy4nKSB7IC8vIEhhbmRsZSAwLjUgYW5kIC41XG4gICAgICAgIHYgPSBhc3NpZ24obWF0Y2hbbmR4KytdLCBzKTtcbiAgICAgIH1cbiAgICAgIG5keCsrO1xuXG4gICAgICAvLyBDaGVjayBmb3IgZGVjaW1hbCBwbGFjZXNcbiAgICAgIGlmIChuZHggKyAxID09PSBtYXRjaC5sZW5ndGggfHwgbWF0Y2hbbmR4ICsgMV0gPT09ICcoJyAmJiBtYXRjaFtuZHggKyAzXSA9PT0gJyknIHx8IG1hdGNoW25keCArIDFdID09PSBcIidcIiAmJiBtYXRjaFtuZHggKyAzXSA9PT0gXCInXCIpIHtcbiAgICAgICAgdyA9IGFzc2lnbihtYXRjaFtuZHhdLCBzKTtcbiAgICAgICAgeSA9IENfVEVOICoqIEJpZ0ludChtYXRjaFtuZHhdLmxlbmd0aCk7XG4gICAgICAgIG5keCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgcmVwZWF0aW5nIHBsYWNlc1xuICAgICAgaWYgKG1hdGNoW25keF0gPT09ICcoJyAmJiBtYXRjaFtuZHggKyAyXSA9PT0gJyknIHx8IG1hdGNoW25keF0gPT09IFwiJ1wiICYmIG1hdGNoW25keCArIDJdID09PSBcIidcIikge1xuICAgICAgICB4ID0gYXNzaWduKG1hdGNoW25keCArIDFdLCBzKTtcbiAgICAgICAgeiA9IENfVEVOICoqIEJpZ0ludChtYXRjaFtuZHggKyAxXS5sZW5ndGgpIC0gQ19PTkU7XG4gICAgICAgIG5keCArPSAzO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChtYXRjaFtuZHggKyAxXSA9PT0gJy8nIHx8IG1hdGNoW25keCArIDFdID09PSAnOicpIHsgLy8gQ2hlY2sgZm9yIGEgc2ltcGxlIGZyYWN0aW9uIFwiMTIzLzQ1NlwiIG9yIFwiMTIzOjQ1NlwiXG4gICAgICB3ID0gYXNzaWduKG1hdGNoW25keF0sIHMpO1xuICAgICAgeSA9IGFzc2lnbihtYXRjaFtuZHggKyAyXSwgQ19PTkUpO1xuICAgICAgbmR4ICs9IDM7XG4gICAgfSBlbHNlIGlmIChtYXRjaFtuZHggKyAzXSA9PT0gJy8nICYmIG1hdGNoW25keCArIDFdID09PSAnICcpIHsgLy8gQ2hlY2sgZm9yIGEgY29tcGxleCBmcmFjdGlvbiBcIjEyMyAxLzJcIlxuICAgICAgdiA9IGFzc2lnbihtYXRjaFtuZHhdLCBzKTtcbiAgICAgIHcgPSBhc3NpZ24obWF0Y2hbbmR4ICsgMl0sIHMpO1xuICAgICAgeSA9IGFzc2lnbihtYXRjaFtuZHggKyA0XSwgQ19PTkUpO1xuICAgICAgbmR4ICs9IDU7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLmxlbmd0aCA8PSBuZHgpIHsgLy8gQ2hlY2sgZm9yIG1vcmUgdG9rZW5zIG9uIHRoZSBzdGFja1xuICAgICAgZCA9IHkgKiB6O1xuICAgICAgcyA9IC8qIHZvaWQgKi9cbiAgICAgICAgbiA9IHggKyBkICogdiArIHogKiB3O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBJbnZhbGlkUGFyYW1ldGVyKCk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAodHlwZW9mIHAxID09PSBcImJpZ2ludFwiKSB7XG4gICAgbiA9IHAxO1xuICAgIHMgPSBwMTtcbiAgICBkID0gQ19PTkU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgSW52YWxpZFBhcmFtZXRlcigpO1xuICB9XG5cbiAgaWYgKGQgPT09IENfWkVSTykge1xuICAgIHRocm93IERpdmlzaW9uQnlaZXJvKCk7XG4gIH1cblxuICBQW1wic1wiXSA9IHMgPCBDX1pFUk8gPyAtQ19PTkUgOiBDX09ORTtcbiAgUFtcIm5cIl0gPSBuIDwgQ19aRVJPID8gLW4gOiBuO1xuICBQW1wiZFwiXSA9IGQgPCBDX1pFUk8gPyAtZCA6IGQ7XG59O1xuXG5mdW5jdGlvbiBtb2Rwb3coYiwgZSwgbSkge1xuXG4gIGxldCByID0gQ19PTkU7XG4gIGZvciAoOyBlID4gQ19aRVJPOyBiID0gKGIgKiBiKSAlIG0sIGUgPj49IENfT05FKSB7XG5cbiAgICBpZiAoZSAmIENfT05FKSB7XG4gICAgICByID0gKHIgKiBiKSAlIG07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBjeWNsZUxlbihuLCBkKSB7XG5cbiAgZm9yICg7IGQgJSBDX1RXTyA9PT0gQ19aRVJPO1xuICAgIGQgLz0gQ19UV08pIHtcbiAgfVxuXG4gIGZvciAoOyBkICUgQ19GSVZFID09PSBDX1pFUk87XG4gICAgZCAvPSBDX0ZJVkUpIHtcbiAgfVxuXG4gIGlmIChkID09PSBDX09ORSkgLy8gQ2F0Y2ggbm9uLWN5Y2xpYyBudW1iZXJzXG4gICAgcmV0dXJuIENfWkVSTztcblxuICAvLyBJZiB3ZSB3b3VsZCBsaWtlIHRvIGNvbXB1dGUgcmVhbGx5IGxhcmdlIG51bWJlcnMgcXVpY2tlciwgd2UgY291bGQgbWFrZSB1c2Ugb2YgRmVybWF0J3MgbGl0dGxlIHRoZW9yZW06XG4gIC8vIDEwXihkLTEpICUgZCA9PSAxXG4gIC8vIEhvd2V2ZXIsIHdlIGRvbid0IG5lZWQgc3VjaCBsYXJnZSBudW1iZXJzIGFuZCBNQVhfQ1lDTEVfTEVOIHNob3VsZCBiZSB0aGUgY2Fwc3RvbmUsXG4gIC8vIGFzIHdlIHdhbnQgdG8gdHJhbnNsYXRlIHRoZSBudW1iZXJzIHRvIHN0cmluZ3MuXG5cbiAgbGV0IHJlbSA9IENfVEVOICUgZDtcbiAgbGV0IHQgPSAxO1xuXG4gIGZvciAoOyByZW0gIT09IENfT05FOyB0KyspIHtcbiAgICByZW0gPSByZW0gKiBDX1RFTiAlIGQ7XG5cbiAgICBpZiAodCA+IE1BWF9DWUNMRV9MRU4pXG4gICAgICByZXR1cm4gQ19aRVJPOyAvLyBSZXR1cm5pbmcgMCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3QgcHJpbnQgaXQgYXMgYSBjeWNsaWMgbnVtYmVyLiBJdCdzIGxpa2VseSB0aGF0IHRoZSBhbnN3ZXIgaXMgYGQtMWBcbiAgfVxuICByZXR1cm4gQmlnSW50KHQpO1xufVxuXG5mdW5jdGlvbiBjeWNsZVN0YXJ0KG4sIGQsIGxlbikge1xuXG4gIGxldCByZW0xID0gQ19PTkU7XG4gIGxldCByZW0yID0gbW9kcG93KENfVEVOLCBsZW4sIGQpO1xuXG4gIGZvciAobGV0IHQgPSAwOyB0IDwgMzAwOyB0KyspIHsgLy8gcyA8IH5sb2cxMChOdW1iZXIuTUFYX1ZBTFVFKVxuICAgIC8vIFNvbHZlIDEwXnMgPT0gMTBeKHMrdCkgKG1vZCBkKVxuXG4gICAgaWYgKHJlbTEgPT09IHJlbTIpXG4gICAgICByZXR1cm4gQmlnSW50KHQpO1xuXG4gICAgcmVtMSA9IHJlbTEgKiBDX1RFTiAlIGQ7XG4gICAgcmVtMiA9IHJlbTIgKiBDX1RFTiAlIGQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGdjZChhLCBiKSB7XG5cbiAgaWYgKCFhKVxuICAgIHJldHVybiBiO1xuICBpZiAoIWIpXG4gICAgcmV0dXJuIGE7XG5cbiAgd2hpbGUgKDEpIHtcbiAgICBhICU9IGI7XG4gICAgaWYgKCFhKVxuICAgICAgcmV0dXJuIGI7XG4gICAgYiAlPSBhO1xuICAgIGlmICghYilcbiAgICAgIHJldHVybiBhO1xuICB9XG59XG5cbi8qKlxuICogTW9kdWxlIGNvbnN0cnVjdG9yXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcnxGcmFjdGlvbj19IGFcbiAqIEBwYXJhbSB7bnVtYmVyPX0gYlxuICovXG5mdW5jdGlvbiBGcmFjdGlvbihhLCBiKSB7XG5cbiAgcGFyc2UoYSwgYik7XG5cbiAgaWYgKHRoaXMgaW5zdGFuY2VvZiBGcmFjdGlvbikge1xuICAgIGEgPSBnY2QoUFtcImRcIl0sIFBbXCJuXCJdKTsgLy8gQWJ1c2UgYVxuICAgIHRoaXNbXCJzXCJdID0gUFtcInNcIl07XG4gICAgdGhpc1tcIm5cIl0gPSBQW1wiblwiXSAvIGE7XG4gICAgdGhpc1tcImRcIl0gPSBQW1wiZFwiXSAvIGE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFBbJ3MnXSAqIFBbJ24nXSwgUFsnZCddKTtcbiAgfVxufVxuXG52YXIgRGl2aXNpb25CeVplcm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXJyb3IoXCJEaXZpc2lvbiBieSBaZXJvXCIpOyB9O1xudmFyIEludmFsaWRQYXJhbWV0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpOyB9O1xudmFyIE5vbkludGVnZXJQYXJhbWV0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRXJyb3IoXCJQYXJhbWV0ZXJzIG11c3QgYmUgaW50ZWdlclwiKTsgfTtcblxuRnJhY3Rpb24ucHJvdG90eXBlID0ge1xuXG4gIFwic1wiOiBDX09ORSxcbiAgXCJuXCI6IENfWkVSTyxcbiAgXCJkXCI6IENfT05FLFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZVxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKC00KS5hYnMoKSA9PiA0XG4gICAqKi9cbiAgXCJhYnNcIjogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRoaXNbXCJuXCJdLCB0aGlzW1wiZFwiXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludmVydHMgdGhlIHNpZ24gb2YgdGhlIGN1cnJlbnQgZnJhY3Rpb25cbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigtNCkubmVnKCkgPT4gNFxuICAgKiovXG4gIFwibmVnXCI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXdGcmFjdGlvbigtdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSwgdGhpc1tcImRcIl0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oe246IDIsIGQ6IDN9KS5hZGQoXCIxNC45XCIpID0+IDQ2NyAvIDMwXG4gICAqKi9cbiAgXCJhZGRcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSArIFBbXCJzXCJdICogdGhpc1tcImRcIl0gKiBQW1wiblwiXSxcbiAgICAgIHRoaXNbXCJkXCJdICogUFtcImRcIl1cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTdWJ0cmFjdHMgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbih7bjogMiwgZDogM30pLmFkZChcIjE0LjlcIikgPT4gLTQyNyAvIDMwXG4gICAqKi9cbiAgXCJzdWJcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiBuZXdGcmFjdGlvbihcbiAgICAgIHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSAtIFBbXCJzXCJdICogdGhpc1tcImRcIl0gKiBQW1wiblwiXSxcbiAgICAgIHRoaXNbXCJkXCJdICogUFtcImRcIl1cbiAgICApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNdWx0aXBsaWVzIHR3byByYXRpb25hbCBudW1iZXJzXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oXCItMTcuKDM0NSlcIikubXVsKDMpID0+IDU3NzYgLyAxMTFcbiAgICoqL1xuICBcIm11bFwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFxuICAgICAgdGhpc1tcInNcIl0gKiBQW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcIm5cIl0sXG4gICAgICB0aGlzW1wiZFwiXSAqIFBbXCJkXCJdXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogRGl2aWRlcyB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiLTE3LigzNDUpXCIpLmludmVyc2UoKS5kaXYoMylcbiAgICoqL1xuICBcImRpdlwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFxuICAgICAgdGhpc1tcInNcIl0gKiBQW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0sXG4gICAgICB0aGlzW1wiZFwiXSAqIFBbXCJuXCJdXG4gICAgKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVzIHRoZSBhY3R1YWwgb2JqZWN0XG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oXCItMTcuKDM0NSlcIikuY2xvbmUoKVxuICAgKiovXG4gIFwiY2xvbmVcIjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXdGcmFjdGlvbih0aGlzWydzJ10gKiB0aGlzWyduJ10sIHRoaXNbJ2QnXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1vZHVsbyBvZiB0d28gcmF0aW9uYWwgbnVtYmVycyAtIGEgbW9yZSBwcmVjaXNlIGZtb2RcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5tb2QoWzcsIDhdKSA9PiAoMTMvMykgJSAoNy84KSA9ICg1LzYpXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oMjAsIDEwKS5tb2QoKS5lcXVhbHMoMCkgPyBcImlzIEludGVnZXJcIlxuICAgKiovXG4gIFwibW9kXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAlIHRoaXNbXCJkXCJdLCBDX09ORSk7XG4gICAgfVxuXG4gICAgcGFyc2UoYSwgYik7XG4gICAgaWYgKENfWkVSTyA9PT0gUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSkge1xuICAgICAgdGhyb3cgRGl2aXNpb25CeVplcm8oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJIGRlcml2ZWQgdGhlIHJhdGlvbmFsIG1vZHVsbyBzaW1pbGFyIHRvIHRoZSBtb2R1bG8gZm9yIGludGVnZXJzXG4gICAgICpcbiAgICAgKiBodHRwczovL3Jhdy5vcmcvYm9vay9hbmFseXNpcy9yYXRpb25hbC1udW1iZXJzL1xuICAgICAqXG4gICAgICogICAgbjEvZDEgPSAobjIvZDIpICogcSArIHIsIHdoZXJlIDAg4omkIHIgPCBuMi9kMlxuICAgICAqID0+IGQyICogbjEgPSBuMiAqIGQxICogcSArIGQxICogZDIgKiByXG4gICAgICogPT4gciA9IChkMiAqIG4xIC0gbjIgKiBkMSAqIHEpIC8gKGQxICogZDIpXG4gICAgICogICAgICA9IChkMiAqIG4xIC0gbjIgKiBkMSAqIGZsb29yKChkMiAqIG4xKSAvIChuMiAqIGQxKSkpIC8gKGQxICogZDIpXG4gICAgICogICAgICA9ICgoZDIgKiBuMSkgJSAobjIgKiBkMSkpIC8gKGQxICogZDIpXG4gICAgICovXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKFxuICAgICAgdGhpc1tcInNcIl0gKiAoUFtcImRcIl0gKiB0aGlzW1wiblwiXSkgJSAoUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSksXG4gICAgICBQW1wiZFwiXSAqIHRoaXNbXCJkXCJdKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZnJhY3Rpb25hbCBnY2Qgb2YgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbig1LDgpLmdjZCgzLDcpID0+IDEvNTZcbiAgICovXG4gIFwiZ2NkXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcblxuICAgIC8vIGh0dHBzOi8vcmF3Lm9yZy9ib29rL2FuYWx5c2lzL3JhdGlvbmFsLW51bWJlcnMvXG4gICAgLy8gZ2NkKGEgLyBiLCBjIC8gZCkgPSBnY2QoYSwgYykgLyBsY20oYiwgZClcblxuICAgIHJldHVybiBuZXdGcmFjdGlvbihnY2QoUFtcIm5cIl0sIHRoaXNbXCJuXCJdKSAqIGdjZChQW1wiZFwiXSwgdGhpc1tcImRcIl0pLCBQW1wiZFwiXSAqIHRoaXNbXCJkXCJdKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZnJhY3Rpb25hbCBsY20gb2YgdHdvIHJhdGlvbmFsIG51bWJlcnNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbig1LDgpLmxjbSgzLDcpID0+IDE1XG4gICAqL1xuICBcImxjbVwiOiBmdW5jdGlvbiAoYSwgYikge1xuXG4gICAgcGFyc2UoYSwgYik7XG5cbiAgICAvLyBodHRwczovL3Jhdy5vcmcvYm9vay9hbmFseXNpcy9yYXRpb25hbC1udW1iZXJzL1xuICAgIC8vIGxjbShhIC8gYiwgYyAvIGQpID0gbGNtKGEsIGMpIC8gZ2NkKGIsIGQpXG5cbiAgICBpZiAoUFtcIm5cIl0gPT09IENfWkVSTyAmJiB0aGlzW1wiblwiXSA9PT0gQ19aRVJPKSB7XG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24oQ19aRVJPLCBDX09ORSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdGcmFjdGlvbihQW1wiblwiXSAqIHRoaXNbXCJuXCJdLCBnY2QoUFtcIm5cIl0sIHRoaXNbXCJuXCJdKSAqIGdjZChQW1wiZFwiXSwgdGhpc1tcImRcIl0pKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgaW52ZXJzZSBvZiB0aGUgZnJhY3Rpb24sIG1lYW5zIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3IgYXJlIGV4Y2hhbmdlZFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFstMywgNF0pLmludmVyc2UoKSA9PiAtNCAvIDNcbiAgICoqL1xuICBcImludmVyc2VcIjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXdGcmFjdGlvbih0aGlzW1wic1wiXSAqIHRoaXNbXCJkXCJdLCB0aGlzW1wiblwiXSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGZyYWN0aW9uIHRvIHNvbWUgaW50ZWdlciBleHBvbmVudFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKC0xLDIpLnBvdygtMykgPT4gLThcbiAgICovXG4gIFwicG93XCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcblxuICAgIC8vIFRyaXZpYWwgY2FzZSB3aGVuIGV4cCBpcyBhbiBpbnRlZ2VyXG5cbiAgICBpZiAoUFsnZCddID09PSBDX09ORSkge1xuXG4gICAgICBpZiAoUFsncyddIDwgQ19aRVJPKSB7XG4gICAgICAgIHJldHVybiBuZXdGcmFjdGlvbigodGhpc1sncyddICogdGhpc1tcImRcIl0pICoqIFBbJ24nXSwgdGhpc1tcIm5cIl0gKiogUFsnbiddKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXdGcmFjdGlvbigodGhpc1sncyddICogdGhpc1tcIm5cIl0pICoqIFBbJ24nXSwgdGhpc1tcImRcIl0gKiogUFsnbiddKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBOZWdhdGl2ZSByb290cyBiZWNvbWUgY29tcGxleFxuICAgIC8vICAgICAoLWEvYileKGMvZCkgPSB4XG4gICAgLy8g4oeUICgtMSleKGMvZCkgKiAoYS9iKV4oYy9kKSA9IHhcbiAgICAvLyDih5QgKGNvcyhwaSkgKyBpKnNpbihwaSkpXihjL2QpICogKGEvYileKGMvZCkgPSB4XG4gICAgLy8g4oeUIChjb3MoYypwaS9kKSArIGkqc2luKGMqcGkvZCkpICogKGEvYileKGMvZCkgPSB4ICAgICAgICMgRGVNb2l2cmUncyBmb3JtdWxhXG4gICAgLy8gRnJvbSB3aGljaCBmb2xsb3dzIHRoYXQgb25seSBmb3IgYz0wIHRoZSByb290IGlzIG5vbi1jb21wbGV4XG4gICAgaWYgKHRoaXNbJ3MnXSA8IENfWkVSTykgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBOb3cgcHJpbWUgZmFjdG9yIG4gYW5kIGRcbiAgICBsZXQgTiA9IGZhY3Rvcml6ZSh0aGlzWyduJ10pO1xuICAgIGxldCBEID0gZmFjdG9yaXplKHRoaXNbJ2QnXSk7XG5cbiAgICAvLyBFeHBvbmVudGlhdGUgYW5kIHRha2Ugcm9vdCBmb3IgbiBhbmQgZCBpbmRpdmlkdWFsbHlcbiAgICBsZXQgbiA9IENfT05FO1xuICAgIGxldCBkID0gQ19PTkU7XG4gICAgZm9yIChsZXQgayBpbiBOKSB7XG4gICAgICBpZiAoayA9PT0gJzEnKSBjb250aW51ZTtcbiAgICAgIGlmIChrID09PSAnMCcpIHtcbiAgICAgICAgbiA9IENfWkVSTztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBOW2tdICo9IFBbJ24nXTtcblxuICAgICAgaWYgKE5ba10gJSBQWydkJ10gPT09IENfWkVSTykge1xuICAgICAgICBOW2tdIC89IFBbJ2QnXTtcbiAgICAgIH0gZWxzZSByZXR1cm4gbnVsbDtcbiAgICAgIG4gKj0gQmlnSW50KGspICoqIE5ba107XG4gICAgfVxuXG4gICAgZm9yIChsZXQgayBpbiBEKSB7XG4gICAgICBpZiAoayA9PT0gJzEnKSBjb250aW51ZTtcbiAgICAgIERba10gKj0gUFsnbiddO1xuXG4gICAgICBpZiAoRFtrXSAlIFBbJ2QnXSA9PT0gQ19aRVJPKSB7XG4gICAgICAgIERba10gLz0gUFsnZCddO1xuICAgICAgfSBlbHNlIHJldHVybiBudWxsO1xuICAgICAgZCAqPSBCaWdJbnQoaykgKiogRFtrXTtcbiAgICB9XG5cbiAgICBpZiAoUFsncyddIDwgQ19aRVJPKSB7XG4gICAgICByZXR1cm4gbmV3RnJhY3Rpb24oZCwgbik7XG4gICAgfVxuICAgIHJldHVybiBuZXdGcmFjdGlvbihuLCBkKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbG9nYXJpdGhtIG9mIGEgZnJhY3Rpb24gdG8gYSBnaXZlbiByYXRpb25hbCBiYXNlXG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oMjcsIDgpLmxvZyg5LCA0KSA9PiAzLzJcbiAgICovXG4gIFwibG9nXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcblxuICAgIGlmICh0aGlzWydzJ10gPD0gQ19aRVJPIHx8IFBbJ3MnXSA8PSBDX1pFUk8pIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgYWxsUHJpbWVzID0ge307XG5cbiAgICBjb25zdCBiYXNlRmFjdG9ycyA9IGZhY3Rvcml6ZShQWyduJ10pO1xuICAgIGNvbnN0IFQxID0gZmFjdG9yaXplKFBbJ2QnXSk7XG5cbiAgICBjb25zdCBudW1iZXJGYWN0b3JzID0gZmFjdG9yaXplKHRoaXNbJ24nXSk7XG4gICAgY29uc3QgVDIgPSBmYWN0b3JpemUodGhpc1snZCddKTtcblxuICAgIGZvciAoY29uc3QgcHJpbWUgaW4gVDEpIHtcbiAgICAgIGJhc2VGYWN0b3JzW3ByaW1lXSA9IChiYXNlRmFjdG9yc1twcmltZV0gfHwgQ19aRVJPKSAtIFQxW3ByaW1lXTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcmltZSBpbiBUMikge1xuICAgICAgbnVtYmVyRmFjdG9yc1twcmltZV0gPSAobnVtYmVyRmFjdG9yc1twcmltZV0gfHwgQ19aRVJPKSAtIFQyW3ByaW1lXTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByaW1lIGluIGJhc2VGYWN0b3JzKSB7XG4gICAgICBpZiAocHJpbWUgPT09ICcxJykgY29udGludWU7XG4gICAgICBhbGxQcmltZXNbcHJpbWVdID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwcmltZSBpbiBudW1iZXJGYWN0b3JzKSB7XG4gICAgICBpZiAocHJpbWUgPT09ICcxJykgY29udGludWU7XG4gICAgICBhbGxQcmltZXNbcHJpbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcmV0TiA9IG51bGw7XG4gICAgbGV0IHJldEQgPSBudWxsO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCB1bmlxdWUgcHJpbWVzIHRvIGRldGVybWluZSBpZiBhIGNvbnNpc3RlbnQgcmF0aW8gZXhpc3RzXG4gICAgZm9yIChjb25zdCBwcmltZSBpbiBhbGxQcmltZXMpIHtcblxuICAgICAgY29uc3QgYmFzZUV4cG9uZW50ID0gYmFzZUZhY3RvcnNbcHJpbWVdIHx8IENfWkVSTztcbiAgICAgIGNvbnN0IG51bWJlckV4cG9uZW50ID0gbnVtYmVyRmFjdG9yc1twcmltZV0gfHwgQ19aRVJPO1xuXG4gICAgICBpZiAoYmFzZUV4cG9uZW50ID09PSBDX1pFUk8pIHtcbiAgICAgICAgaWYgKG51bWJlckV4cG9uZW50ICE9PSBDX1pFUk8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gTG9nYXJpdGhtIGNhbm5vdCBiZSBleHByZXNzZWQgYXMgYSByYXRpb25hbCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0aGlzIHByaW1lIHNpbmNlIGJvdGggZXhwb25lbnRzIGFyZSB6ZXJvXG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmF0aW8gb2YgZXhwb25lbnRzIGZvciB0aGlzIHByaW1lXG4gICAgICBsZXQgY3VyTiA9IG51bWJlckV4cG9uZW50O1xuICAgICAgbGV0IGN1ckQgPSBiYXNlRXhwb25lbnQ7XG5cbiAgICAgIC8vIFNpbXBsaWZ5IHRoZSBjdXJyZW50IHJhdGlvXG4gICAgICBjb25zdCBnY2RWYWx1ZSA9IGdjZChjdXJOLCBjdXJEKTtcbiAgICAgIGN1ck4gLz0gZ2NkVmFsdWU7XG4gICAgICBjdXJEIC89IGdjZFZhbHVlO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBmaXJzdCByYXRpbzsgb3RoZXJ3aXNlLCBlbnN1cmUgcmF0aW9zIGFyZSBjb25zaXN0ZW50XG4gICAgICBpZiAocmV0TiA9PT0gbnVsbCAmJiByZXREID09PSBudWxsKSB7XG4gICAgICAgIHJldE4gPSBjdXJOO1xuICAgICAgICByZXREID0gY3VyRDtcbiAgICAgIH0gZWxzZSBpZiAoY3VyTiAqIHJldEQgIT09IHJldE4gKiBjdXJEKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBSYXRpb3MgZG8gbm90IG1hdGNoLCBsb2dhcml0aG0gY2Fubm90IGJlIHJhdGlvbmFsXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldE4gIT09IG51bGwgJiYgcmV0RCAhPT0gbnVsbFxuICAgICAgPyBuZXdGcmFjdGlvbihyZXROLCByZXREKVxuICAgICAgOiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gcmF0aW9uYWwgbnVtYmVycyBhcmUgdGhlIHNhbWVcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5lcXVhbHMoWzk4LCA1XSk7XG4gICAqKi9cbiAgXCJlcXVhbHNcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiB0aGlzW1wic1wiXSAqIHRoaXNbXCJuXCJdICogUFtcImRcIl0gPT09IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyByYXRpb25hbCBudW1iZXIgaXMgbGVzcyB0aGFuIGFub3RoZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5sdChbOTgsIDVdKTtcbiAgICoqL1xuICBcImx0XCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdIDwgUFtcInNcIl0gKiBQW1wiblwiXSAqIHRoaXNbXCJkXCJdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIHJhdGlvbmFsIG51bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgYW5vdGhlclxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmx0KFs5OCwgNV0pO1xuICAgKiovXG4gIFwibHRlXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdIDw9IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyByYXRpb25hbCBudW1iZXIgaXMgZ3JlYXRlciB0aGFuIGFub3RoZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbigxOS42KS5sdChbOTgsIDVdKTtcbiAgICoqL1xuICBcImd0XCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdID4gUFtcInNcIl0gKiBQW1wiblwiXSAqIHRoaXNbXCJkXCJdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGlzIHJhdGlvbmFsIG51bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgYW5vdGhlclxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmx0KFs5OCwgNV0pO1xuICAgKiovXG4gIFwiZ3RlXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICByZXR1cm4gdGhpc1tcInNcIl0gKiB0aGlzW1wiblwiXSAqIFBbXCJkXCJdID49IFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcbiAgfSxcblxuICAvKipcbiAgICogQ29tcGFyZSB0d28gcmF0aW9uYWwgbnVtYmVyc1xuICAgKiA8IDAgaWZmIHRoaXMgPCB0aGF0XG4gICAqID4gMCBpZmYgdGhpcyA+IHRoYXRcbiAgICogPSAwIGlmZiB0aGlzID0gdGhhdFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmNvbXBhcmUoWzk4LCA1XSk7XG4gICAqKi9cbiAgXCJjb21wYXJlXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICBwYXJzZShhLCBiKTtcbiAgICBsZXQgdCA9IHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0gKiBQW1wiZFwiXSAtIFBbXCJzXCJdICogUFtcIm5cIl0gKiB0aGlzW1wiZFwiXTtcblxuICAgIHJldHVybiAoQ19aRVJPIDwgdCkgLSAodCA8IENfWkVSTyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGNlaWwgb2YgYSByYXRpb25hbCBudW1iZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5jZWlsKCkgPT4gKDUgLyAxKVxuICAgKiovXG4gIFwiY2VpbFwiOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cbiAgICBwbGFjZXMgPSBDX1RFTiAqKiBCaWdJbnQocGxhY2VzIHx8IDApO1xuXG4gICAgcmV0dXJuIG5ld0ZyYWN0aW9uKHRydW5jKHRoaXNbXCJzXCJdICogcGxhY2VzICogdGhpc1tcIm5cIl0gLyB0aGlzW1wiZFwiXSkgK1xuICAgICAgKHBsYWNlcyAqIHRoaXNbXCJuXCJdICUgdGhpc1tcImRcIl0gPiBDX1pFUk8gJiYgdGhpc1tcInNcIl0gPj0gQ19aRVJPID8gQ19PTkUgOiBDX1pFUk8pLFxuICAgICAgcGxhY2VzKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZmxvb3Igb2YgYSByYXRpb25hbCBudW1iZXJcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5mbG9vcigpID0+ICg0IC8gMSlcbiAgICoqL1xuICBcImZsb29yXCI6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblxuICAgIHBsYWNlcyA9IENfVEVOICoqIEJpZ0ludChwbGFjZXMgfHwgMCk7XG5cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24odHJ1bmModGhpc1tcInNcIl0gKiBwbGFjZXMgKiB0aGlzW1wiblwiXSAvIHRoaXNbXCJkXCJdKSAtXG4gICAgICAocGxhY2VzICogdGhpc1tcIm5cIl0gJSB0aGlzW1wiZFwiXSA+IENfWkVSTyAmJiB0aGlzW1wic1wiXSA8IENfWkVSTyA/IENfT05FIDogQ19aRVJPKSxcbiAgICAgIHBsYWNlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJvdW5kcyBhIHJhdGlvbmFsIG51bWJlcnNcbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbignNC4oMyknKS5yb3VuZCgpID0+ICg0IC8gMSlcbiAgICoqL1xuICBcInJvdW5kXCI6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblxuICAgIHBsYWNlcyA9IENfVEVOICoqIEJpZ0ludChwbGFjZXMgfHwgMCk7XG5cbiAgICAvKiBEZXJpdmF0aW9uOlxuXG4gICAgcyA+PSAwOlxuICAgICAgcm91bmQobiAvIGQpID0gdHJ1bmMobiAvIGQpICsgKG4gJSBkKSAvIGQgPj0gMC41ID8gMSA6IDBcbiAgICAgICAgICAgICAgICAgICA9IHRydW5jKG4gLyBkKSArIDIobiAlIGQpID49IGQgPyAxIDogMFxuICAgIHMgPCAwOlxuICAgICAgcm91bmQobiAvIGQpID0tdHJ1bmMobiAvIGQpIC0gKG4gJSBkKSAvIGQgPiAwLjUgPyAxIDogMFxuICAgICAgICAgICAgICAgICAgID0tdHJ1bmMobiAvIGQpIC0gMihuICUgZCkgPiBkID8gMSA6IDBcblxuICAgID0+OlxuXG4gICAgcm91bmQocyAqIG4gLyBkKSA9IHMgKiB0cnVuYyhuIC8gZCkgKyBzICogKEMgKyAyKG4gJSBkKSA+IGQgPyAxIDogMClcbiAgICAgICAgd2hlcmUgQyA9IHMgPj0gMCA/IDEgOiAwLCB0byBmaXggdGhlID49IGZvciB0aGUgcG9zaXR2ZSBjYXNlLlxuICAgICovXG5cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24odHJ1bmModGhpc1tcInNcIl0gKiBwbGFjZXMgKiB0aGlzW1wiblwiXSAvIHRoaXNbXCJkXCJdKSArXG4gICAgICB0aGlzW1wic1wiXSAqICgodGhpc1tcInNcIl0gPj0gQ19aRVJPID8gQ19PTkUgOiBDX1pFUk8pICsgQ19UV08gKiAocGxhY2VzICogdGhpc1tcIm5cIl0gJSB0aGlzW1wiZFwiXSkgPiB0aGlzW1wiZFwiXSA/IENfT05FIDogQ19aRVJPKSxcbiAgICAgIHBsYWNlcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAgKiBSb3VuZHMgYSByYXRpb25hbCBudW1iZXIgdG8gYSBtdWx0aXBsZSBvZiBhbm90aGVyIHJhdGlvbmFsIG51bWJlclxuICAgICpcbiAgICAqIEV4OiBuZXcgRnJhY3Rpb24oJzAuOScpLnJvdW5kVG8oXCIxLzhcIikgPT4gNyAvIDhcbiAgICAqKi9cbiAgXCJyb3VuZFRvXCI6IGZ1bmN0aW9uIChhLCBiKSB7XG5cbiAgICAvKlxuICAgIGsgKiB4L3kg4omkIGEvYiA8IChrKzEpICogeC95XG4gICAg4oeUIGsg4omkIGEvYiAvICh4L3kpIDwgKGsrMSlcbiAgICDih5QgayA9IGZsb29yKGEvYiAqIHkveClcbiAgICDih5QgayA9IGZsb29yKChhICogeSkgLyAoYiAqIHgpKVxuICAgICovXG5cbiAgICBwYXJzZShhLCBiKTtcblxuICAgIGNvbnN0IG4gPSB0aGlzWyduJ10gKiBQWydkJ107XG4gICAgY29uc3QgZCA9IHRoaXNbJ2QnXSAqIFBbJ24nXTtcbiAgICBjb25zdCByID0gbiAlIGQ7XG5cbiAgICAvLyByb3VuZChuIC8gZCkgPSB0cnVuYyhuIC8gZCkgKyAyKG4gJSBkKSA+PSBkID8gMSA6IDBcbiAgICBsZXQgayA9IHRydW5jKG4gLyBkKTtcbiAgICBpZiAociArIHIgPj0gZCkge1xuICAgICAgaysrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RnJhY3Rpb24odGhpc1sncyddICogayAqIFBbJ24nXSwgUFsnZCddKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIHJhdGlvbmFsIG51bWJlcnMgYXJlIGRpdmlzaWJsZVxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKDE5LjYpLmRpdmlzaWJsZSgxLjUpO1xuICAgKi9cbiAgXCJkaXZpc2libGVcIjogZnVuY3Rpb24gKGEsIGIpIHtcblxuICAgIHBhcnNlKGEsIGIpO1xuICAgIHJldHVybiAhKCEoUFtcIm5cIl0gKiB0aGlzW1wiZFwiXSkgfHwgKCh0aGlzW1wiblwiXSAqIFBbXCJkXCJdKSAlIChQW1wiblwiXSAqIHRoaXNbXCJkXCJdKSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnJhY3Rpb25cbiAgICpcbiAgICogRXg6IG5ldyBGcmFjdGlvbihcIjEwMC4nOTE4MjMnXCIpLnZhbHVlT2YoKSA9PiAxMDAuOTE4MjM5MTgyMzkxODNcbiAgICoqL1xuICAndmFsdWVPZic6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBCZXN0IHdlIGNhbiBkbyBzbyBmYXJcbiAgICByZXR1cm4gTnVtYmVyKHRoaXNbXCJzXCJdICogdGhpc1tcIm5cIl0pIC8gTnVtYmVyKHRoaXNbXCJkXCJdKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZyYWN0aW9uIHdpdGggYWxsIGRpZ2l0c1xuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMTAwLic5MTgyMydcIikudG9TdHJpbmcoKSA9PiBcIjEwMC4oOTE4MjMpXCJcbiAgICoqL1xuICAndG9TdHJpbmcnOiBmdW5jdGlvbiAoZGVjKSB7XG5cbiAgICBsZXQgTiA9IHRoaXNbXCJuXCJdO1xuICAgIGxldCBEID0gdGhpc1tcImRcIl07XG5cbiAgICBkZWMgPSBkZWMgfHwgMTU7IC8vIDE1ID0gZGVjaW1hbCBwbGFjZXMgd2hlbiBubyByZXBldGl0aW9uXG5cbiAgICBsZXQgY3ljTGVuID0gY3ljbGVMZW4oTiwgRCk7IC8vIEN5Y2xlIGxlbmd0aFxuICAgIGxldCBjeWNPZmYgPSBjeWNsZVN0YXJ0KE4sIEQsIGN5Y0xlbik7IC8vIEN5Y2xlIHN0YXJ0XG5cbiAgICBsZXQgc3RyID0gdGhpc1sncyddIDwgQ19aRVJPID8gXCItXCIgOiBcIlwiO1xuXG4gICAgLy8gQXBwZW5kIGludGVnZXIgcGFydFxuICAgIHN0ciArPSB0cnVuYyhOIC8gRCk7XG5cbiAgICBOICU9IEQ7XG4gICAgTiAqPSBDX1RFTjtcblxuICAgIGlmIChOKVxuICAgICAgc3RyICs9IFwiLlwiO1xuXG4gICAgaWYgKGN5Y0xlbikge1xuXG4gICAgICBmb3IgKGxldCBpID0gY3ljT2ZmOyBpLS07KSB7XG4gICAgICAgIHN0ciArPSB0cnVuYyhOIC8gRCk7XG4gICAgICAgIE4gJT0gRDtcbiAgICAgICAgTiAqPSBDX1RFTjtcbiAgICAgIH1cbiAgICAgIHN0ciArPSBcIihcIjtcbiAgICAgIGZvciAobGV0IGkgPSBjeWNMZW47IGktLTspIHtcbiAgICAgICAgc3RyICs9IHRydW5jKE4gLyBEKTtcbiAgICAgICAgTiAlPSBEO1xuICAgICAgICBOICo9IENfVEVOO1xuICAgICAgfVxuICAgICAgc3RyICs9IFwiKVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gZGVjOyBOICYmIGktLTspIHtcbiAgICAgICAgc3RyICs9IHRydW5jKE4gLyBEKTtcbiAgICAgICAgTiAlPSBEO1xuICAgICAgICBOICo9IENfVEVOO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nLWZyYWN0aW9uIHJlcHJlc2VudGF0aW9uIG9mIGEgRnJhY3Rpb24gb2JqZWN0XG4gICAqXG4gICAqIEV4OiBuZXcgRnJhY3Rpb24oXCIxLiczJ1wiKS50b0ZyYWN0aW9uKCkgPT4gXCI0IDEvM1wiXG4gICAqKi9cbiAgJ3RvRnJhY3Rpb24nOiBmdW5jdGlvbiAoc2hvd01peGVkKSB7XG5cbiAgICBsZXQgbiA9IHRoaXNbXCJuXCJdO1xuICAgIGxldCBkID0gdGhpc1tcImRcIl07XG4gICAgbGV0IHN0ciA9IHRoaXNbJ3MnXSA8IENfWkVSTyA/IFwiLVwiIDogXCJcIjtcblxuICAgIGlmIChkID09PSBDX09ORSkge1xuICAgICAgc3RyICs9IG47XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB3aG9sZSA9IHRydW5jKG4gLyBkKTtcbiAgICAgIGlmIChzaG93TWl4ZWQgJiYgd2hvbGUgPiBDX1pFUk8pIHtcbiAgICAgICAgc3RyICs9IHdob2xlO1xuICAgICAgICBzdHIgKz0gXCIgXCI7XG4gICAgICAgIG4gJT0gZDtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IG47XG4gICAgICBzdHIgKz0gJy8nO1xuICAgICAgc3RyICs9IGQ7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsYXRleCByZXByZXNlbnRhdGlvbiBvZiBhIEZyYWN0aW9uIG9iamVjdFxuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiMS4nMydcIikudG9MYXRleCgpID0+IFwiXFxmcmFjezR9ezN9XCJcbiAgICoqL1xuICAndG9MYXRleCc6IGZ1bmN0aW9uIChzaG93TWl4ZWQpIHtcblxuICAgIGxldCBuID0gdGhpc1tcIm5cIl07XG4gICAgbGV0IGQgPSB0aGlzW1wiZFwiXTtcbiAgICBsZXQgc3RyID0gdGhpc1sncyddIDwgQ19aRVJPID8gXCItXCIgOiBcIlwiO1xuXG4gICAgaWYgKGQgPT09IENfT05FKSB7XG4gICAgICBzdHIgKz0gbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHdob2xlID0gdHJ1bmMobiAvIGQpO1xuICAgICAgaWYgKHNob3dNaXhlZCAmJiB3aG9sZSA+IENfWkVSTykge1xuICAgICAgICBzdHIgKz0gd2hvbGU7XG4gICAgICAgIG4gJT0gZDtcbiAgICAgIH1cblxuICAgICAgc3RyICs9IFwiXFxcXGZyYWN7XCI7XG4gICAgICBzdHIgKz0gbjtcbiAgICAgIHN0ciArPSAnfXsnO1xuICAgICAgc3RyICs9IGQ7XG4gICAgICBzdHIgKz0gJ30nO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbnRpbnVlZCBmcmFjdGlvbiBlbGVtZW50c1xuICAgKlxuICAgKiBFeDogbmV3IEZyYWN0aW9uKFwiNy84XCIpLnRvQ29udGludWVkKCkgPT4gWzAsMSw3XVxuICAgKi9cbiAgJ3RvQ29udGludWVkJzogZnVuY3Rpb24gKCkge1xuXG4gICAgbGV0IGEgPSB0aGlzWyduJ107XG4gICAgbGV0IGIgPSB0aGlzWydkJ107XG4gICAgbGV0IHJlcyA9IFtdO1xuXG4gICAgZG8ge1xuICAgICAgcmVzLnB1c2godHJ1bmMoYSAvIGIpKTtcbiAgICAgIGxldCB0ID0gYSAlIGI7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0O1xuICAgIH0gd2hpbGUgKGEgIT09IENfT05FKTtcblxuICAgIHJldHVybiByZXM7XG4gIH0sXG5cbiAgXCJzaW1wbGlmeVwiOiBmdW5jdGlvbiAoZXBzKSB7XG5cbiAgICBjb25zdCBpZXBzID0gQmlnSW50KDEgLyAoZXBzIHx8IDAuMDAxKSB8IDApO1xuXG4gICAgY29uc3QgdGhpc0FCUyA9IHRoaXNbJ2FicyddKCk7XG4gICAgY29uc3QgY29udCA9IHRoaXNBQlNbJ3RvQ29udGludWVkJ10oKTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgY29udC5sZW5ndGg7IGkrKykge1xuXG4gICAgICBsZXQgcyA9IG5ld0ZyYWN0aW9uKGNvbnRbaSAtIDFdLCBDX09ORSk7XG4gICAgICBmb3IgKGxldCBrID0gaSAtIDI7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgIHMgPSBzWydpbnZlcnNlJ10oKVsnYWRkJ10oY29udFtrXSk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ID0gc1snc3ViJ10odGhpc0FCUyk7XG4gICAgICBpZiAodFsnbiddICogaWVwcyA8IHRbJ2QnXSkgeyAvLyBNb3JlIHJvYnVzdCB0aGFuIE1hdGguYWJzKHQudmFsdWVPZigpKSA8IGVwc1xuICAgICAgICByZXR1cm4gc1snbXVsJ10odGhpc1sncyddKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5leHBvcnQge1xuICBGcmFjdGlvbiBhcyBkZWZhdWx0LCBGcmFjdGlvblxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/fraction.js/dist/fraction.mjs\n");

/***/ })

};
;